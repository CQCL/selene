; ModuleID = 'hugr'
source_filename = "hugr"
target datalayout = "e-m:o-i64:64-i128:128-n32:64-S128"
target triple = "aarch64-apple-darwin"

@res_cs.46C3C4B5.0 = private constant [16 x i8] c"\0FUSER:BOOLARR:cs"
@res_is.F21393DB.0 = private constant [15 x i8] c"\0EUSER:INTARR:is"
@res_fs.CBD4AF54.0 = private constant [17 x i8] c"\10USER:FLOATARR:fs"
@"e_Array inde.2A1CB845.0" = private constant [35 x i8] c"\22EXIT:INT:Array index out of bounds"
@"e_Linear arr.8A243695.0" = private constant [48 x i8] c"/EXIT:INT:Linear array element has not been used"
@"e_Linear arr.27F92A51.0" = private constant [52 x i8] c"3EXIT:INT:Linear array element has already been used"
@e_ArrayIter..ED8B8605.0 = private constant [69 x i8] c"DEXIT:INT:ArrayIter._assert_all_used: array element has not been used"
@"e_No more qu.3B2EEBF0.0" = private constant [47 x i8] c".EXIT:INT:No more qubits available to allocate."

define void @__hugr__.main.1() local_unnamed_addr {
alloca_block:
  %0 = tail call i8* @heap_alloc(i64 1600)
  call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 8 dereferenceable(1600) %0, i8 0, i64 1600, i1 false)
  %1 = tail call i8* @heap_alloc(i64 1600)
  call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 4 dereferenceable(1600) %1, i8 0, i64 1600, i1 false)
  %2 = bitcast i8* %0 to { i1, double }*
  %3 = tail call i8* @heap_alloc(i64 160)
  call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 4 dereferenceable(160) %3, i8 0, i64 160, i1 false)
  %4 = bitcast i8* %1 to { i1, i64 }*
  %5 = bitcast i8* %3 to { i1, i64 }*
  br label %loop_body

loop_body:                                        ; preds = %alloca_block, %cond_424_case_1.i
  %"20_2.0" = phi i64 [ %6, %cond_424_case_1.i ], [ 0, %alloca_block ]
  %exitcond.not = icmp eq i64 %"20_2.0", 10
  br i1 %exitcond.not, label %loop_out, label %cond_25_case_1

cond_25_case_1:                                   ; preds = %loop_body
  %6 = add nuw nsw i64 %"20_2.0", 1
  %qalloc.i = tail call i64 @___qalloc()
  %not_max.not.i = icmp eq i64 %qalloc.i, -1
  br i1 %not_max.not.i, label %id_bb.i, label %reset_bb.i

reset_bb.i:                                       ; preds = %cond_25_case_1
  tail call void @___reset(i64 %qalloc.i)
  br label %id_bb.i

id_bb.i:                                          ; preds = %reset_bb.i, %cond_25_case_1
  %7 = insertvalue { i1, i64 } { i1 true, i64 poison }, i64 %qalloc.i, 1
  %8 = select i1 %not_max.not.i, { i1, i64 } { i1 false, i64 poison }, { i1, i64 } %7
  %.fca.0.extract.i = extractvalue { i1, i64 } %8, 0
  br i1 %.fca.0.extract.i, label %cond_424_case_1.i, label %cond_387_case_0.i

cond_387_case_0.i:                                ; preds = %id_bb.i
  tail call void @panic(i32 1001, i8* getelementptr inbounds ([47 x i8], [47 x i8]* @"e_No more qu.3B2EEBF0.0", i64 0, i64 0))
  unreachable

cond_424_case_1.i:                                ; preds = %id_bb.i
  %.fca.1.extract.i = extractvalue { i1, i64 } %8, 1
  %"421_05.fca.1.insert.i" = insertvalue { i1, i64 } { i1 true, i64 poison }, i64 %.fca.1.extract.i, 1
  %9 = getelementptr inbounds { i1, i64 }, { i1, i64 }* %5, i64 %"20_2.0"
  %10 = getelementptr inbounds { i1, i64 }, { i1, i64 }* %9, i64 0, i32 0
  %11 = load i1, i1* %10, align 1
  store { i1, i64 } %"421_05.fca.1.insert.i", { i1, i64 }* %9, align 4
  br i1 %11, label %cond_434_case_1.i, label %loop_body

cond_434_case_1.i:                                ; preds = %cond_424_case_1.i
  tail call void @panic(i32 1001, i8* getelementptr inbounds ([48 x i8], [48 x i8]* @"e_Linear arr.8A243695.0", i64 0, i64 0))
  unreachable

loop_out:                                         ; preds = %loop_body
  %"133.fca.0.insert" = insertvalue { { i1, i64 }*, i64 } poison, { i1, i64 }* %5, 0
  %"133.fca.1.insert" = insertvalue { { i1, i64 }*, i64 } %"133.fca.0.insert", i64 0, 1
  %12 = load { i1, i64 }, { i1, i64 }* %5, align 4
  tail call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 4 dereferenceable(16) %3, i8 0, i64 16, i1 false)
  %.fca.2.0.extract.i = extractvalue { i1, i64 } %12, 0
  br i1 %.fca.2.0.extract.i, label %"__hugr__.$array.__getitem__.linear.2$$t(qubit)$n(10).444.exit", label %cond_460_case_0.i

cond_460_case_0.i:                                ; preds = %loop_out
  tail call void @panic(i32 1001, i8* getelementptr inbounds ([52 x i8], [52 x i8]* @"e_Linear arr.27F92A51.0", i64 0, i64 0))
  unreachable

"__hugr__.$array.__getitem__.linear.2$$t(qubit)$n(10).444.exit": ; preds = %loop_out
  %.fca.2.1.extract.i = extractvalue { i1, i64 } %12, 1
  tail call void @___rxy(i64 %.fca.2.1.extract.i, double 0x400921FB54442D18, double 0.000000e+00)
  %"421_05.fca.1.insert.i635" = insertvalue { i1, i64 } { i1 true, i64 poison }, i64 %.fca.2.1.extract.i, 1
  %13 = bitcast i8* %3 to i1*
  %14 = load i1, i1* %13, align 1
  store { i1, i64 } %"421_05.fca.1.insert.i635", { i1, i64 }* %5, align 4
  br i1 %14, label %cond_434_case_1.i637, label %"__hugr__.$array.__setitem__.linear.4$$t(qubit)$n(10).418.exit638"

cond_434_case_1.i637:                             ; preds = %"__hugr__.$array.__getitem__.linear.2$$t(qubit)$n(10).444.exit"
  tail call void @panic(i32 1001, i8* getelementptr inbounds ([48 x i8], [48 x i8]* @"e_Linear arr.8A243695.0", i64 0, i64 0))
  unreachable

"__hugr__.$array.__setitem__.linear.4$$t(qubit)$n(10).418.exit638": ; preds = %"__hugr__.$array.__getitem__.linear.2$$t(qubit)$n(10).444.exit"
  %15 = getelementptr inbounds i8, i8* %3, i64 32
  %16 = bitcast i8* %15 to { i1, i64 }*
  %17 = load { i1, i64 }, { i1, i64 }* %16, align 4
  tail call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 4 dereferenceable(16) %15, i8 0, i64 16, i1 false)
  %.fca.2.0.extract.i639 = extractvalue { i1, i64 } %17, 0
  br i1 %.fca.2.0.extract.i639, label %"__hugr__.$array.__getitem__.linear.2$$t(qubit)$n(10).444.exit644", label %cond_460_case_0.i643

cond_460_case_0.i643:                             ; preds = %"__hugr__.$array.__setitem__.linear.4$$t(qubit)$n(10).418.exit638"
  tail call void @panic(i32 1001, i8* getelementptr inbounds ([52 x i8], [52 x i8]* @"e_Linear arr.27F92A51.0", i64 0, i64 0))
  unreachable

"__hugr__.$array.__getitem__.linear.2$$t(qubit)$n(10).444.exit644": ; preds = %"__hugr__.$array.__setitem__.linear.4$$t(qubit)$n(10).418.exit638"
  %.fca.2.1.extract.i640 = extractvalue { i1, i64 } %17, 1
  tail call void @___rxy(i64 %.fca.2.1.extract.i640, double 0x400921FB54442D18, double 0.000000e+00)
  %"421_05.fca.1.insert.i645" = insertvalue { i1, i64 } { i1 true, i64 poison }, i64 %.fca.2.1.extract.i640, 1
  %18 = bitcast i8* %15 to i1*
  %19 = load i1, i1* %18, align 1
  store { i1, i64 } %"421_05.fca.1.insert.i645", { i1, i64 }* %16, align 4
  br i1 %19, label %cond_434_case_1.i649, label %"__hugr__.$array.__setitem__.linear.4$$t(qubit)$n(10).418.exit650"

cond_434_case_1.i649:                             ; preds = %"__hugr__.$array.__getitem__.linear.2$$t(qubit)$n(10).444.exit644"
  tail call void @panic(i32 1001, i8* getelementptr inbounds ([48 x i8], [48 x i8]* @"e_Linear arr.8A243695.0", i64 0, i64 0))
  unreachable

"__hugr__.$array.__setitem__.linear.4$$t(qubit)$n(10).418.exit650": ; preds = %"__hugr__.$array.__getitem__.linear.2$$t(qubit)$n(10).444.exit644"
  %20 = getelementptr inbounds i8, i8* %3, i64 48
  %21 = bitcast i8* %20 to { i1, i64 }*
  %22 = load { i1, i64 }, { i1, i64 }* %21, align 4
  tail call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 4 dereferenceable(16) %20, i8 0, i64 16, i1 false)
  %.fca.2.0.extract.i653 = extractvalue { i1, i64 } %22, 0
  br i1 %.fca.2.0.extract.i653, label %"__hugr__.$array.__getitem__.linear.2$$t(qubit)$n(10).444.exit658", label %cond_460_case_0.i657

cond_460_case_0.i657:                             ; preds = %"__hugr__.$array.__setitem__.linear.4$$t(qubit)$n(10).418.exit650"
  tail call void @panic(i32 1001, i8* getelementptr inbounds ([52 x i8], [52 x i8]* @"e_Linear arr.27F92A51.0", i64 0, i64 0))
  unreachable

"__hugr__.$array.__getitem__.linear.2$$t(qubit)$n(10).444.exit658": ; preds = %"__hugr__.$array.__setitem__.linear.4$$t(qubit)$n(10).418.exit650"
  %.fca.2.1.extract.i654 = extractvalue { i1, i64 } %22, 1
  tail call void @___rxy(i64 %.fca.2.1.extract.i654, double 0x400921FB54442D18, double 0.000000e+00)
  %"421_05.fca.1.insert.i659" = insertvalue { i1, i64 } { i1 true, i64 poison }, i64 %.fca.2.1.extract.i654, 1
  %23 = bitcast i8* %20 to i1*
  %24 = load i1, i1* %23, align 1
  store { i1, i64 } %"421_05.fca.1.insert.i659", { i1, i64 }* %21, align 4
  br i1 %24, label %cond_434_case_1.i663, label %"__hugr__.$array.__setitem__.linear.4$$t(qubit)$n(10).418.exit664"

cond_434_case_1.i663:                             ; preds = %"__hugr__.$array.__getitem__.linear.2$$t(qubit)$n(10).444.exit658"
  tail call void @panic(i32 1001, i8* getelementptr inbounds ([48 x i8], [48 x i8]* @"e_Linear arr.8A243695.0", i64 0, i64 0))
  unreachable

"__hugr__.$array.__setitem__.linear.4$$t(qubit)$n(10).418.exit664": ; preds = %"__hugr__.$array.__getitem__.linear.2$$t(qubit)$n(10).444.exit658"
  %25 = getelementptr inbounds i8, i8* %3, i64 144
  %26 = bitcast i8* %25 to { i1, i64 }*
  %27 = load { i1, i64 }, { i1, i64 }* %26, align 4
  tail call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 4 dereferenceable(16) %25, i8 0, i64 16, i1 false)
  %.fca.2.0.extract.i667 = extractvalue { i1, i64 } %27, 0
  br i1 %.fca.2.0.extract.i667, label %"__hugr__.$array.__getitem__.linear.2$$t(qubit)$n(10).444.exit672", label %cond_460_case_0.i671

cond_460_case_0.i671:                             ; preds = %"__hugr__.$array.__setitem__.linear.4$$t(qubit)$n(10).418.exit664"
  tail call void @panic(i32 1001, i8* getelementptr inbounds ([52 x i8], [52 x i8]* @"e_Linear arr.27F92A51.0", i64 0, i64 0))
  unreachable

"__hugr__.$array.__getitem__.linear.2$$t(qubit)$n(10).444.exit672": ; preds = %"__hugr__.$array.__setitem__.linear.4$$t(qubit)$n(10).418.exit664"
  %.fca.2.1.extract.i668 = extractvalue { i1, i64 } %27, 1
  tail call void @___rxy(i64 %.fca.2.1.extract.i668, double 0x400921FB54442D18, double 0.000000e+00)
  %"421_05.fca.1.insert.i673" = insertvalue { i1, i64 } { i1 true, i64 poison }, i64 %.fca.2.1.extract.i668, 1
  %28 = bitcast i8* %25 to i1*
  %29 = load i1, i1* %28, align 1
  store { i1, i64 } %"421_05.fca.1.insert.i673", { i1, i64 }* %26, align 4
  br i1 %29, label %cond_434_case_1.i677, label %"__hugr__.$array.__setitem__.linear.4$$t(qubit)$n(10).418.exit678"

cond_434_case_1.i677:                             ; preds = %"__hugr__.$array.__getitem__.linear.2$$t(qubit)$n(10).444.exit672"
  tail call void @panic(i32 1001, i8* getelementptr inbounds ([48 x i8], [48 x i8]* @"e_Linear arr.8A243695.0", i64 0, i64 0))
  unreachable

"__hugr__.$array.__setitem__.linear.4$$t(qubit)$n(10).418.exit678": ; preds = %"__hugr__.$array.__getitem__.linear.2$$t(qubit)$n(10).444.exit672"
  %30 = tail call { { i1, { i1, i64, i1 } }*, i64 } @"__hugr__.$measure_array$$n(10).472"({ { i1, i64 }*, i64 } %"133.fca.1.insert")
  %.fca.0.extract335 = extractvalue { { i1, { i1, i64, i1 } }*, i64 } %30, 0
  %.fca.1.extract336 = extractvalue { { i1, { i1, i64, i1 } }*, i64 } %30, 1
  %31 = tail call i8* @heap_alloc(i64 240)
  %32 = bitcast i8* %31 to { i1, i64, i1 }*
  %33 = getelementptr inbounds { i1, { i1, i64, i1 } }, { i1, { i1, i64, i1 } }* %.fca.0.extract335, i64 %.fca.1.extract336
  %34 = load { i1, { i1, i64, i1 } }, { i1, { i1, i64, i1 } }* %33, align 4
  %.fca.0.extract11.i = extractvalue { i1, { i1, i64, i1 } } %34, 0
  br i1 %.fca.0.extract11.i, label %"__hugr__.$array.__unwrap_elem.7$$t(bool).598.exit", label %cond_601_case_0.i

cond_601_case_0.i:                                ; preds = %"__hugr__.$array.__unwrap_elem.7$$t(bool).598.exit.8", %"__hugr__.$array.__unwrap_elem.7$$t(bool).598.exit.7", %"__hugr__.$array.__unwrap_elem.7$$t(bool).598.exit.6", %"__hugr__.$array.__unwrap_elem.7$$t(bool).598.exit.5", %"__hugr__.$array.__unwrap_elem.7$$t(bool).598.exit.4", %"__hugr__.$array.__unwrap_elem.7$$t(bool).598.exit.3", %"__hugr__.$array.__unwrap_elem.7$$t(bool).598.exit.2", %"__hugr__.$array.__unwrap_elem.7$$t(bool).598.exit.1", %"__hugr__.$array.__unwrap_elem.7$$t(bool).598.exit", %"__hugr__.$array.__setitem__.linear.4$$t(qubit)$n(10).418.exit678"
  tail call void @panic(i32 1001, i8* getelementptr inbounds ([52 x i8], [52 x i8]* @"e_Linear arr.27F92A51.0", i64 0, i64 0))
  unreachable

"__hugr__.$array.__unwrap_elem.7$$t(bool).598.exit": ; preds = %"__hugr__.$array.__setitem__.linear.4$$t(qubit)$n(10).418.exit678"
  %35 = extractvalue { i1, { i1, i64, i1 } } %34, 1
  store { i1, i64, i1 } %35, { i1, i64, i1 }* %32, align 4
  %36 = add i64 %.fca.1.extract336, 1
  %37 = getelementptr inbounds { i1, { i1, i64, i1 } }, { i1, { i1, i64, i1 } }* %.fca.0.extract335, i64 %36
  %38 = load { i1, { i1, i64, i1 } }, { i1, { i1, i64, i1 } }* %37, align 4
  %.fca.0.extract11.i.1 = extractvalue { i1, { i1, i64, i1 } } %38, 0
  br i1 %.fca.0.extract11.i.1, label %"__hugr__.$array.__unwrap_elem.7$$t(bool).598.exit.1", label %cond_601_case_0.i

"__hugr__.$array.__unwrap_elem.7$$t(bool).598.exit.1": ; preds = %"__hugr__.$array.__unwrap_elem.7$$t(bool).598.exit"
  %39 = extractvalue { i1, { i1, i64, i1 } } %38, 1
  %40 = getelementptr inbounds i8, i8* %31, i64 24
  %41 = bitcast i8* %40 to { i1, i64, i1 }*
  store { i1, i64, i1 } %39, { i1, i64, i1 }* %41, align 4
  %42 = add i64 %.fca.1.extract336, 2
  %43 = getelementptr inbounds { i1, { i1, i64, i1 } }, { i1, { i1, i64, i1 } }* %.fca.0.extract335, i64 %42
  %44 = load { i1, { i1, i64, i1 } }, { i1, { i1, i64, i1 } }* %43, align 4
  %.fca.0.extract11.i.2 = extractvalue { i1, { i1, i64, i1 } } %44, 0
  br i1 %.fca.0.extract11.i.2, label %"__hugr__.$array.__unwrap_elem.7$$t(bool).598.exit.2", label %cond_601_case_0.i

"__hugr__.$array.__unwrap_elem.7$$t(bool).598.exit.2": ; preds = %"__hugr__.$array.__unwrap_elem.7$$t(bool).598.exit.1"
  %45 = extractvalue { i1, { i1, i64, i1 } } %44, 1
  %46 = getelementptr inbounds i8, i8* %31, i64 48
  %47 = bitcast i8* %46 to { i1, i64, i1 }*
  store { i1, i64, i1 } %45, { i1, i64, i1 }* %47, align 4
  %48 = add i64 %.fca.1.extract336, 3
  %49 = getelementptr inbounds { i1, { i1, i64, i1 } }, { i1, { i1, i64, i1 } }* %.fca.0.extract335, i64 %48
  %50 = load { i1, { i1, i64, i1 } }, { i1, { i1, i64, i1 } }* %49, align 4
  %.fca.0.extract11.i.3 = extractvalue { i1, { i1, i64, i1 } } %50, 0
  br i1 %.fca.0.extract11.i.3, label %"__hugr__.$array.__unwrap_elem.7$$t(bool).598.exit.3", label %cond_601_case_0.i

"__hugr__.$array.__unwrap_elem.7$$t(bool).598.exit.3": ; preds = %"__hugr__.$array.__unwrap_elem.7$$t(bool).598.exit.2"
  %51 = extractvalue { i1, { i1, i64, i1 } } %50, 1
  %52 = getelementptr inbounds i8, i8* %31, i64 72
  %53 = bitcast i8* %52 to { i1, i64, i1 }*
  store { i1, i64, i1 } %51, { i1, i64, i1 }* %53, align 4
  %54 = add i64 %.fca.1.extract336, 4
  %55 = getelementptr inbounds { i1, { i1, i64, i1 } }, { i1, { i1, i64, i1 } }* %.fca.0.extract335, i64 %54
  %56 = load { i1, { i1, i64, i1 } }, { i1, { i1, i64, i1 } }* %55, align 4
  %.fca.0.extract11.i.4 = extractvalue { i1, { i1, i64, i1 } } %56, 0
  br i1 %.fca.0.extract11.i.4, label %"__hugr__.$array.__unwrap_elem.7$$t(bool).598.exit.4", label %cond_601_case_0.i

"__hugr__.$array.__unwrap_elem.7$$t(bool).598.exit.4": ; preds = %"__hugr__.$array.__unwrap_elem.7$$t(bool).598.exit.3"
  %57 = extractvalue { i1, { i1, i64, i1 } } %56, 1
  %58 = getelementptr inbounds i8, i8* %31, i64 96
  %59 = bitcast i8* %58 to { i1, i64, i1 }*
  store { i1, i64, i1 } %57, { i1, i64, i1 }* %59, align 4
  %60 = add i64 %.fca.1.extract336, 5
  %61 = getelementptr inbounds { i1, { i1, i64, i1 } }, { i1, { i1, i64, i1 } }* %.fca.0.extract335, i64 %60
  %62 = load { i1, { i1, i64, i1 } }, { i1, { i1, i64, i1 } }* %61, align 4
  %.fca.0.extract11.i.5 = extractvalue { i1, { i1, i64, i1 } } %62, 0
  br i1 %.fca.0.extract11.i.5, label %"__hugr__.$array.__unwrap_elem.7$$t(bool).598.exit.5", label %cond_601_case_0.i

"__hugr__.$array.__unwrap_elem.7$$t(bool).598.exit.5": ; preds = %"__hugr__.$array.__unwrap_elem.7$$t(bool).598.exit.4"
  %63 = extractvalue { i1, { i1, i64, i1 } } %62, 1
  %64 = getelementptr inbounds i8, i8* %31, i64 120
  %65 = bitcast i8* %64 to { i1, i64, i1 }*
  store { i1, i64, i1 } %63, { i1, i64, i1 }* %65, align 4
  %66 = add i64 %.fca.1.extract336, 6
  %67 = getelementptr inbounds { i1, { i1, i64, i1 } }, { i1, { i1, i64, i1 } }* %.fca.0.extract335, i64 %66
  %68 = load { i1, { i1, i64, i1 } }, { i1, { i1, i64, i1 } }* %67, align 4
  %.fca.0.extract11.i.6 = extractvalue { i1, { i1, i64, i1 } } %68, 0
  br i1 %.fca.0.extract11.i.6, label %"__hugr__.$array.__unwrap_elem.7$$t(bool).598.exit.6", label %cond_601_case_0.i

"__hugr__.$array.__unwrap_elem.7$$t(bool).598.exit.6": ; preds = %"__hugr__.$array.__unwrap_elem.7$$t(bool).598.exit.5"
  %69 = extractvalue { i1, { i1, i64, i1 } } %68, 1
  %70 = getelementptr inbounds i8, i8* %31, i64 144
  %71 = bitcast i8* %70 to { i1, i64, i1 }*
  store { i1, i64, i1 } %69, { i1, i64, i1 }* %71, align 4
  %72 = add i64 %.fca.1.extract336, 7
  %73 = getelementptr inbounds { i1, { i1, i64, i1 } }, { i1, { i1, i64, i1 } }* %.fca.0.extract335, i64 %72
  %74 = load { i1, { i1, i64, i1 } }, { i1, { i1, i64, i1 } }* %73, align 4
  %.fca.0.extract11.i.7 = extractvalue { i1, { i1, i64, i1 } } %74, 0
  br i1 %.fca.0.extract11.i.7, label %"__hugr__.$array.__unwrap_elem.7$$t(bool).598.exit.7", label %cond_601_case_0.i

"__hugr__.$array.__unwrap_elem.7$$t(bool).598.exit.7": ; preds = %"__hugr__.$array.__unwrap_elem.7$$t(bool).598.exit.6"
  %75 = extractvalue { i1, { i1, i64, i1 } } %74, 1
  %76 = getelementptr inbounds i8, i8* %31, i64 168
  %77 = bitcast i8* %76 to { i1, i64, i1 }*
  store { i1, i64, i1 } %75, { i1, i64, i1 }* %77, align 4
  %78 = add i64 %.fca.1.extract336, 8
  %79 = getelementptr inbounds { i1, { i1, i64, i1 } }, { i1, { i1, i64, i1 } }* %.fca.0.extract335, i64 %78
  %80 = load { i1, { i1, i64, i1 } }, { i1, { i1, i64, i1 } }* %79, align 4
  %.fca.0.extract11.i.8 = extractvalue { i1, { i1, i64, i1 } } %80, 0
  br i1 %.fca.0.extract11.i.8, label %"__hugr__.$array.__unwrap_elem.7$$t(bool).598.exit.8", label %cond_601_case_0.i

"__hugr__.$array.__unwrap_elem.7$$t(bool).598.exit.8": ; preds = %"__hugr__.$array.__unwrap_elem.7$$t(bool).598.exit.7"
  %81 = extractvalue { i1, { i1, i64, i1 } } %80, 1
  %82 = getelementptr inbounds i8, i8* %31, i64 192
  %83 = bitcast i8* %82 to { i1, i64, i1 }*
  store { i1, i64, i1 } %81, { i1, i64, i1 }* %83, align 4
  %84 = add i64 %.fca.1.extract336, 9
  %85 = getelementptr inbounds { i1, { i1, i64, i1 } }, { i1, { i1, i64, i1 } }* %.fca.0.extract335, i64 %84
  %86 = load { i1, { i1, i64, i1 } }, { i1, { i1, i64, i1 } }* %85, align 4
  %.fca.0.extract11.i.9 = extractvalue { i1, { i1, i64, i1 } } %86, 0
  br i1 %.fca.0.extract11.i.9, label %"__hugr__.$array.__unwrap_elem.7$$t(bool).598.exit.9", label %cond_601_case_0.i

"__hugr__.$array.__unwrap_elem.7$$t(bool).598.exit.9": ; preds = %"__hugr__.$array.__unwrap_elem.7$$t(bool).598.exit.8"
  %87 = extractvalue { i1, { i1, i64, i1 } } %86, 1
  %88 = getelementptr inbounds i8, i8* %31, i64 216
  %89 = bitcast i8* %88 to { i1, i64, i1 }*
  store { i1, i64, i1 } %87, { i1, i64, i1 }* %89, align 4
  %90 = bitcast { i1, { i1, i64, i1 } }* %.fca.0.extract335 to i8*
  tail call void @heap_free(i8* %90)
  %91 = tail call i8* @heap_alloc(i64 10)
  %92 = load { i1, i64, i1 }, { i1, i64, i1 }* %32, align 4
  %.fca.0.extract.i679 = extractvalue { i1, i64, i1 } %92, 0
  %.fca.1.extract.i680 = extractvalue { i1, i64, i1 } %92, 1
  br i1 %.fca.0.extract.i679, label %cond_365_case_1.i, label %cond_365_case_0.i

cond_365_case_0.i:                                ; preds = %"__hugr__.$array.__unwrap_elem.7$$t(bool).598.exit.9"
  %.fca.2.extract.i = extractvalue { i1, i64, i1 } %92, 2
  br label %__hugr__.array.__read_bool.9.312.exit

cond_365_case_1.i:                                ; preds = %"__hugr__.$array.__unwrap_elem.7$$t(bool).598.exit.9"
  %read_bool.i = tail call i1 @___read_future_bool(i64 %.fca.1.extract.i680)
  tail call void @___dec_future_refcount(i64 %.fca.1.extract.i680)
  br label %__hugr__.array.__read_bool.9.312.exit

__hugr__.array.__read_bool.9.312.exit:            ; preds = %cond_365_case_0.i, %cond_365_case_1.i
  %"03.0.i" = phi i1 [ %read_bool.i, %cond_365_case_1.i ], [ %.fca.2.extract.i, %cond_365_case_0.i ]
  %93 = bitcast i8* %91 to i1*
  store i1 %"03.0.i", i1* %93, align 1
  %94 = load { i1, i64, i1 }, { i1, i64, i1 }* %41, align 4
  %.fca.0.extract.i679.1 = extractvalue { i1, i64, i1 } %94, 0
  %.fca.1.extract.i680.1 = extractvalue { i1, i64, i1 } %94, 1
  br i1 %.fca.0.extract.i679.1, label %cond_365_case_1.i.1, label %cond_365_case_0.i.1

cond_365_case_0.i.1:                              ; preds = %__hugr__.array.__read_bool.9.312.exit
  %.fca.2.extract.i.1 = extractvalue { i1, i64, i1 } %94, 2
  br label %__hugr__.array.__read_bool.9.312.exit.1

cond_365_case_1.i.1:                              ; preds = %__hugr__.array.__read_bool.9.312.exit
  %read_bool.i.1 = tail call i1 @___read_future_bool(i64 %.fca.1.extract.i680.1)
  tail call void @___dec_future_refcount(i64 %.fca.1.extract.i680.1)
  br label %__hugr__.array.__read_bool.9.312.exit.1

__hugr__.array.__read_bool.9.312.exit.1:          ; preds = %cond_365_case_1.i.1, %cond_365_case_0.i.1
  %"03.0.i.1" = phi i1 [ %read_bool.i.1, %cond_365_case_1.i.1 ], [ %.fca.2.extract.i.1, %cond_365_case_0.i.1 ]
  %95 = getelementptr inbounds i8, i8* %91, i64 1
  %96 = bitcast i8* %95 to i1*
  store i1 %"03.0.i.1", i1* %96, align 1
  %97 = load { i1, i64, i1 }, { i1, i64, i1 }* %47, align 4
  %.fca.0.extract.i679.2 = extractvalue { i1, i64, i1 } %97, 0
  %.fca.1.extract.i680.2 = extractvalue { i1, i64, i1 } %97, 1
  br i1 %.fca.0.extract.i679.2, label %cond_365_case_1.i.2, label %cond_365_case_0.i.2

cond_365_case_0.i.2:                              ; preds = %__hugr__.array.__read_bool.9.312.exit.1
  %.fca.2.extract.i.2 = extractvalue { i1, i64, i1 } %97, 2
  br label %__hugr__.array.__read_bool.9.312.exit.2

cond_365_case_1.i.2:                              ; preds = %__hugr__.array.__read_bool.9.312.exit.1
  %read_bool.i.2 = tail call i1 @___read_future_bool(i64 %.fca.1.extract.i680.2)
  tail call void @___dec_future_refcount(i64 %.fca.1.extract.i680.2)
  br label %__hugr__.array.__read_bool.9.312.exit.2

__hugr__.array.__read_bool.9.312.exit.2:          ; preds = %cond_365_case_1.i.2, %cond_365_case_0.i.2
  %"03.0.i.2" = phi i1 [ %read_bool.i.2, %cond_365_case_1.i.2 ], [ %.fca.2.extract.i.2, %cond_365_case_0.i.2 ]
  %98 = getelementptr inbounds i8, i8* %91, i64 2
  %99 = bitcast i8* %98 to i1*
  store i1 %"03.0.i.2", i1* %99, align 1
  %100 = load { i1, i64, i1 }, { i1, i64, i1 }* %53, align 4
  %.fca.0.extract.i679.3 = extractvalue { i1, i64, i1 } %100, 0
  %.fca.1.extract.i680.3 = extractvalue { i1, i64, i1 } %100, 1
  br i1 %.fca.0.extract.i679.3, label %cond_365_case_1.i.3, label %cond_365_case_0.i.3

cond_365_case_0.i.3:                              ; preds = %__hugr__.array.__read_bool.9.312.exit.2
  %.fca.2.extract.i.3 = extractvalue { i1, i64, i1 } %100, 2
  br label %__hugr__.array.__read_bool.9.312.exit.3

cond_365_case_1.i.3:                              ; preds = %__hugr__.array.__read_bool.9.312.exit.2
  %read_bool.i.3 = tail call i1 @___read_future_bool(i64 %.fca.1.extract.i680.3)
  tail call void @___dec_future_refcount(i64 %.fca.1.extract.i680.3)
  br label %__hugr__.array.__read_bool.9.312.exit.3

__hugr__.array.__read_bool.9.312.exit.3:          ; preds = %cond_365_case_1.i.3, %cond_365_case_0.i.3
  %"03.0.i.3" = phi i1 [ %read_bool.i.3, %cond_365_case_1.i.3 ], [ %.fca.2.extract.i.3, %cond_365_case_0.i.3 ]
  %101 = getelementptr inbounds i8, i8* %91, i64 3
  %102 = bitcast i8* %101 to i1*
  store i1 %"03.0.i.3", i1* %102, align 1
  %103 = load { i1, i64, i1 }, { i1, i64, i1 }* %59, align 4
  %.fca.0.extract.i679.4 = extractvalue { i1, i64, i1 } %103, 0
  %.fca.1.extract.i680.4 = extractvalue { i1, i64, i1 } %103, 1
  br i1 %.fca.0.extract.i679.4, label %cond_365_case_1.i.4, label %cond_365_case_0.i.4

cond_365_case_0.i.4:                              ; preds = %__hugr__.array.__read_bool.9.312.exit.3
  %.fca.2.extract.i.4 = extractvalue { i1, i64, i1 } %103, 2
  br label %__hugr__.array.__read_bool.9.312.exit.4

cond_365_case_1.i.4:                              ; preds = %__hugr__.array.__read_bool.9.312.exit.3
  %read_bool.i.4 = tail call i1 @___read_future_bool(i64 %.fca.1.extract.i680.4)
  tail call void @___dec_future_refcount(i64 %.fca.1.extract.i680.4)
  br label %__hugr__.array.__read_bool.9.312.exit.4

__hugr__.array.__read_bool.9.312.exit.4:          ; preds = %cond_365_case_1.i.4, %cond_365_case_0.i.4
  %"03.0.i.4" = phi i1 [ %read_bool.i.4, %cond_365_case_1.i.4 ], [ %.fca.2.extract.i.4, %cond_365_case_0.i.4 ]
  %104 = getelementptr inbounds i8, i8* %91, i64 4
  %105 = bitcast i8* %104 to i1*
  store i1 %"03.0.i.4", i1* %105, align 1
  %106 = load { i1, i64, i1 }, { i1, i64, i1 }* %65, align 4
  %.fca.0.extract.i679.5 = extractvalue { i1, i64, i1 } %106, 0
  %.fca.1.extract.i680.5 = extractvalue { i1, i64, i1 } %106, 1
  br i1 %.fca.0.extract.i679.5, label %cond_365_case_1.i.5, label %cond_365_case_0.i.5

cond_365_case_0.i.5:                              ; preds = %__hugr__.array.__read_bool.9.312.exit.4
  %.fca.2.extract.i.5 = extractvalue { i1, i64, i1 } %106, 2
  br label %__hugr__.array.__read_bool.9.312.exit.5

cond_365_case_1.i.5:                              ; preds = %__hugr__.array.__read_bool.9.312.exit.4
  %read_bool.i.5 = tail call i1 @___read_future_bool(i64 %.fca.1.extract.i680.5)
  tail call void @___dec_future_refcount(i64 %.fca.1.extract.i680.5)
  br label %__hugr__.array.__read_bool.9.312.exit.5

__hugr__.array.__read_bool.9.312.exit.5:          ; preds = %cond_365_case_1.i.5, %cond_365_case_0.i.5
  %"03.0.i.5" = phi i1 [ %read_bool.i.5, %cond_365_case_1.i.5 ], [ %.fca.2.extract.i.5, %cond_365_case_0.i.5 ]
  %107 = getelementptr inbounds i8, i8* %91, i64 5
  %108 = bitcast i8* %107 to i1*
  store i1 %"03.0.i.5", i1* %108, align 1
  %109 = load { i1, i64, i1 }, { i1, i64, i1 }* %71, align 4
  %.fca.0.extract.i679.6 = extractvalue { i1, i64, i1 } %109, 0
  %.fca.1.extract.i680.6 = extractvalue { i1, i64, i1 } %109, 1
  br i1 %.fca.0.extract.i679.6, label %cond_365_case_1.i.6, label %cond_365_case_0.i.6

cond_365_case_0.i.6:                              ; preds = %__hugr__.array.__read_bool.9.312.exit.5
  %.fca.2.extract.i.6 = extractvalue { i1, i64, i1 } %109, 2
  br label %__hugr__.array.__read_bool.9.312.exit.6

cond_365_case_1.i.6:                              ; preds = %__hugr__.array.__read_bool.9.312.exit.5
  %read_bool.i.6 = tail call i1 @___read_future_bool(i64 %.fca.1.extract.i680.6)
  tail call void @___dec_future_refcount(i64 %.fca.1.extract.i680.6)
  br label %__hugr__.array.__read_bool.9.312.exit.6

__hugr__.array.__read_bool.9.312.exit.6:          ; preds = %cond_365_case_1.i.6, %cond_365_case_0.i.6
  %"03.0.i.6" = phi i1 [ %read_bool.i.6, %cond_365_case_1.i.6 ], [ %.fca.2.extract.i.6, %cond_365_case_0.i.6 ]
  %110 = getelementptr inbounds i8, i8* %91, i64 6
  %111 = bitcast i8* %110 to i1*
  store i1 %"03.0.i.6", i1* %111, align 1
  %112 = load { i1, i64, i1 }, { i1, i64, i1 }* %77, align 4
  %.fca.0.extract.i679.7 = extractvalue { i1, i64, i1 } %112, 0
  %.fca.1.extract.i680.7 = extractvalue { i1, i64, i1 } %112, 1
  br i1 %.fca.0.extract.i679.7, label %cond_365_case_1.i.7, label %cond_365_case_0.i.7

cond_365_case_0.i.7:                              ; preds = %__hugr__.array.__read_bool.9.312.exit.6
  %.fca.2.extract.i.7 = extractvalue { i1, i64, i1 } %112, 2
  br label %__hugr__.array.__read_bool.9.312.exit.7

cond_365_case_1.i.7:                              ; preds = %__hugr__.array.__read_bool.9.312.exit.6
  %read_bool.i.7 = tail call i1 @___read_future_bool(i64 %.fca.1.extract.i680.7)
  tail call void @___dec_future_refcount(i64 %.fca.1.extract.i680.7)
  br label %__hugr__.array.__read_bool.9.312.exit.7

__hugr__.array.__read_bool.9.312.exit.7:          ; preds = %cond_365_case_1.i.7, %cond_365_case_0.i.7
  %"03.0.i.7" = phi i1 [ %read_bool.i.7, %cond_365_case_1.i.7 ], [ %.fca.2.extract.i.7, %cond_365_case_0.i.7 ]
  %113 = getelementptr inbounds i8, i8* %91, i64 7
  %114 = bitcast i8* %113 to i1*
  store i1 %"03.0.i.7", i1* %114, align 1
  %115 = load { i1, i64, i1 }, { i1, i64, i1 }* %83, align 4
  %.fca.0.extract.i679.8 = extractvalue { i1, i64, i1 } %115, 0
  %.fca.1.extract.i680.8 = extractvalue { i1, i64, i1 } %115, 1
  br i1 %.fca.0.extract.i679.8, label %cond_365_case_1.i.8, label %cond_365_case_0.i.8

cond_365_case_0.i.8:                              ; preds = %__hugr__.array.__read_bool.9.312.exit.7
  %.fca.2.extract.i.8 = extractvalue { i1, i64, i1 } %115, 2
  br label %__hugr__.array.__read_bool.9.312.exit.8

cond_365_case_1.i.8:                              ; preds = %__hugr__.array.__read_bool.9.312.exit.7
  %read_bool.i.8 = tail call i1 @___read_future_bool(i64 %.fca.1.extract.i680.8)
  tail call void @___dec_future_refcount(i64 %.fca.1.extract.i680.8)
  br label %__hugr__.array.__read_bool.9.312.exit.8

__hugr__.array.__read_bool.9.312.exit.8:          ; preds = %cond_365_case_1.i.8, %cond_365_case_0.i.8
  %"03.0.i.8" = phi i1 [ %read_bool.i.8, %cond_365_case_1.i.8 ], [ %.fca.2.extract.i.8, %cond_365_case_0.i.8 ]
  %116 = getelementptr inbounds i8, i8* %91, i64 8
  %117 = bitcast i8* %116 to i1*
  store i1 %"03.0.i.8", i1* %117, align 1
  %118 = load { i1, i64, i1 }, { i1, i64, i1 }* %89, align 4
  %.fca.0.extract.i679.9 = extractvalue { i1, i64, i1 } %118, 0
  %.fca.1.extract.i680.9 = extractvalue { i1, i64, i1 } %118, 1
  br i1 %.fca.0.extract.i679.9, label %cond_365_case_1.i.9, label %cond_365_case_0.i.9

cond_365_case_0.i.9:                              ; preds = %__hugr__.array.__read_bool.9.312.exit.8
  %.fca.2.extract.i.9 = extractvalue { i1, i64, i1 } %118, 2
  br label %__hugr__.array.__read_bool.9.312.exit.9

cond_365_case_1.i.9:                              ; preds = %__hugr__.array.__read_bool.9.312.exit.8
  %read_bool.i.9 = tail call i1 @___read_future_bool(i64 %.fca.1.extract.i680.9)
  tail call void @___dec_future_refcount(i64 %.fca.1.extract.i680.9)
  br label %__hugr__.array.__read_bool.9.312.exit.9

__hugr__.array.__read_bool.9.312.exit.9:          ; preds = %cond_365_case_1.i.9, %cond_365_case_0.i.9
  %"03.0.i.9" = phi i1 [ %read_bool.i.9, %cond_365_case_1.i.9 ], [ %.fca.2.extract.i.9, %cond_365_case_0.i.9 ]
  %119 = getelementptr inbounds i8, i8* %91, i64 9
  %120 = bitcast i8* %119 to i1*
  store i1 %"03.0.i.9", i1* %120, align 1
  tail call void @heap_free(i8* nonnull %31)
  %out_arr_alloca = alloca <{ i32, i32, i1*, i1* }>, align 8
  %x_ptr = getelementptr inbounds <{ i32, i32, i1*, i1* }>, <{ i32, i32, i1*, i1* }>* %out_arr_alloca, i64 0, i32 0
  %y_ptr = getelementptr inbounds <{ i32, i32, i1*, i1* }>, <{ i32, i32, i1*, i1* }>* %out_arr_alloca, i64 0, i32 1
  %arr_ptr = getelementptr inbounds <{ i32, i32, i1*, i1* }>, <{ i32, i32, i1*, i1* }>* %out_arr_alloca, i64 0, i32 2
  %mask_ptr = getelementptr inbounds <{ i32, i32, i1*, i1* }>, <{ i32, i32, i1*, i1* }>* %out_arr_alloca, i64 0, i32 3
  %121 = alloca [10 x i1], align 1
  %.sub = getelementptr inbounds [10 x i1], [10 x i1]* %121, i64 0, i64 0
  %122 = bitcast [10 x i1]* %121 to i8*
  call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 1 dereferenceable(10) %122, i8 0, i64 10, i1 false)
  store i32 10, i32* %x_ptr, align 8
  store i32 1, i32* %y_ptr, align 4
  %123 = bitcast i1** %arr_ptr to i8**
  store i8* %91, i8** %123, align 8
  store i1* %.sub, i1** %mask_ptr, align 8
  call void @print_bool_arr(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @res_cs.46C3C4B5.0, i64 0, i64 0), i64 15, <{ i32, i32, i1*, i1* }>* nonnull %out_arr_alloca)
  br label %cond_exit_97

cond_exit_97:                                     ; preds = %cond_exit_97, %__hugr__.array.__read_bool.9.312.exit.9
  %"92_0.sroa.0.0708" = phi i64 [ 0, %__hugr__.array.__read_bool.9.312.exit.9 ], [ %124, %cond_exit_97 ]
  %124 = add nuw nsw i64 %"92_0.sroa.0.0708", 1
  %"619_05.fca.1.insert.i" = insertvalue { i1, i64 } { i1 true, i64 poison }, i64 %"92_0.sroa.0.0708", 1
  %125 = getelementptr inbounds { i1, i64 }, { i1, i64 }* %4, i64 %"92_0.sroa.0.0708"
  store { i1, i64 } %"619_05.fca.1.insert.i", { i1, i64 }* %125, align 4
  %exitcond715.not = icmp eq i64 %124, 100
  br i1 %exitcond715.not, label %loop_out109, label %cond_exit_97

loop_out109:                                      ; preds = %cond_exit_97
  %126 = call i8* @heap_alloc(i64 800)
  %127 = bitcast i8* %126 to i64*
  br label %128

128:                                              ; preds = %loop_out109, %"__hugr__.$array.__unwrap_elem.7$$t(int(6)).631.exit"
  %storemerge630709 = phi i64 [ 0, %loop_out109 ], [ %132, %"__hugr__.$array.__unwrap_elem.7$$t(int(6)).631.exit" ]
  %129 = getelementptr inbounds { i1, i64 }, { i1, i64 }* %4, i64 %storemerge630709
  %130 = load { i1, i64 }, { i1, i64 }* %129, align 4
  %.fca.0.extract.i685 = extractvalue { i1, i64 } %130, 0
  br i1 %.fca.0.extract.i685, label %"__hugr__.$array.__unwrap_elem.7$$t(int(6)).631.exit", label %cond_634_case_0.i

cond_634_case_0.i:                                ; preds = %128
  call void @panic(i32 1001, i8* getelementptr inbounds ([52 x i8], [52 x i8]* @"e_Linear arr.27F92A51.0", i64 0, i64 0))
  unreachable

"__hugr__.$array.__unwrap_elem.7$$t(int(6)).631.exit": ; preds = %128
  %.fca.1.extract.i686 = extractvalue { i1, i64 } %130, 1
  %131 = getelementptr inbounds i64, i64* %127, i64 %storemerge630709
  store i64 %.fca.1.extract.i686, i64* %131, align 4
  %132 = add nuw nsw i64 %storemerge630709, 1
  %exitcond716.not = icmp eq i64 %132, 100
  br i1 %exitcond716.not, label %133, label %128

133:                                              ; preds = %"__hugr__.$array.__unwrap_elem.7$$t(int(6)).631.exit"
  call void @heap_free(i8* nonnull %1)
  %out_arr_alloca172 = alloca <{ i32, i32, i64*, i1* }>, align 8
  %x_ptr173 = getelementptr inbounds <{ i32, i32, i64*, i1* }>, <{ i32, i32, i64*, i1* }>* %out_arr_alloca172, i64 0, i32 0
  %y_ptr174 = getelementptr inbounds <{ i32, i32, i64*, i1* }>, <{ i32, i32, i64*, i1* }>* %out_arr_alloca172, i64 0, i32 1
  %arr_ptr175 = getelementptr inbounds <{ i32, i32, i64*, i1* }>, <{ i32, i32, i64*, i1* }>* %out_arr_alloca172, i64 0, i32 2
  %mask_ptr176 = getelementptr inbounds <{ i32, i32, i64*, i1* }>, <{ i32, i32, i64*, i1* }>* %out_arr_alloca172, i64 0, i32 3
  %134 = alloca [100 x i1], align 1
  %.sub428 = getelementptr inbounds [100 x i1], [100 x i1]* %134, i64 0, i64 0
  %135 = bitcast [100 x i1]* %134 to i8*
  call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 1 dereferenceable(100) %135, i8 0, i64 100, i1 false)
  store i32 100, i32* %x_ptr173, align 8
  store i32 1, i32* %y_ptr174, align 4
  %136 = bitcast i64** %arr_ptr175 to i8**
  store i8* %126, i8** %136, align 8
  store i1* %.sub428, i1** %mask_ptr176, align 8
  call void @print_int_arr(i8* getelementptr inbounds ([15 x i8], [15 x i8]* @res_is.F21393DB.0, i64 0, i64 0), i64 14, <{ i32, i32, i64*, i1* }>* nonnull %out_arr_alloca172)
  br label %cond_exit_137

cond_exit_137:                                    ; preds = %cond_exit_137, %133
  %"132_0.sroa.0.0711" = phi i64 [ 0, %133 ], [ %137, %cond_exit_137 ]
  %137 = add nuw nsw i64 %"132_0.sroa.0.0711", 1
  %138 = sitofp i64 %"132_0.sroa.0.0711" to double
  %139 = fmul double %138, 6.250000e-02
  %"652_05.fca.1.insert.i" = insertvalue { i1, double } { i1 true, double poison }, double %139, 1
  %140 = getelementptr inbounds { i1, double }, { i1, double }* %2, i64 %"132_0.sroa.0.0711"
  store { i1, double } %"652_05.fca.1.insert.i", { i1, double }* %140, align 8
  %exitcond717.not = icmp eq i64 %137, 100
  br i1 %exitcond717.not, label %loop_out180, label %cond_exit_137

loop_out180:                                      ; preds = %cond_exit_137
  %141 = call i8* @heap_alloc(i64 800)
  %142 = bitcast i8* %141 to double*
  br label %143

143:                                              ; preds = %loop_out180, %"__hugr__.$array.__unwrap_elem.7$$t(float64).664.exit"
  %storemerge712 = phi i64 [ 0, %loop_out180 ], [ %147, %"__hugr__.$array.__unwrap_elem.7$$t(float64).664.exit" ]
  %144 = getelementptr inbounds { i1, double }, { i1, double }* %2, i64 %storemerge712
  %145 = load { i1, double }, { i1, double }* %144, align 8
  %.fca.0.extract.i691 = extractvalue { i1, double } %145, 0
  br i1 %.fca.0.extract.i691, label %"__hugr__.$array.__unwrap_elem.7$$t(float64).664.exit", label %cond_667_case_0.i

cond_667_case_0.i:                                ; preds = %143
  call void @panic(i32 1001, i8* getelementptr inbounds ([52 x i8], [52 x i8]* @"e_Linear arr.27F92A51.0", i64 0, i64 0))
  unreachable

"__hugr__.$array.__unwrap_elem.7$$t(float64).664.exit": ; preds = %143
  %.fca.1.extract.i692 = extractvalue { i1, double } %145, 1
  %146 = getelementptr inbounds double, double* %142, i64 %storemerge712
  store double %.fca.1.extract.i692, double* %146, align 8
  %147 = add nuw nsw i64 %storemerge712, 1
  %exitcond718.not = icmp eq i64 %147, 100
  br i1 %exitcond718.not, label %148, label %143

148:                                              ; preds = %"__hugr__.$array.__unwrap_elem.7$$t(float64).664.exit"
  call void @heap_free(i8* nonnull %0)
  %out_arr_alloca246 = alloca <{ i32, i32, double*, i1* }>, align 8
  %x_ptr247 = getelementptr inbounds <{ i32, i32, double*, i1* }>, <{ i32, i32, double*, i1* }>* %out_arr_alloca246, i64 0, i32 0
  %y_ptr248 = getelementptr inbounds <{ i32, i32, double*, i1* }>, <{ i32, i32, double*, i1* }>* %out_arr_alloca246, i64 0, i32 1
  %arr_ptr249 = getelementptr inbounds <{ i32, i32, double*, i1* }>, <{ i32, i32, double*, i1* }>* %out_arr_alloca246, i64 0, i32 2
  %mask_ptr250 = getelementptr inbounds <{ i32, i32, double*, i1* }>, <{ i32, i32, double*, i1* }>* %out_arr_alloca246, i64 0, i32 3
  %149 = alloca [100 x i1], align 1
  %.sub529 = getelementptr inbounds [100 x i1], [100 x i1]* %149, i64 0, i64 0
  %150 = bitcast [100 x i1]* %149 to i8*
  call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 1 dereferenceable(100) %150, i8 0, i64 100, i1 false)
  store i32 100, i32* %x_ptr247, align 8
  store i32 1, i32* %y_ptr248, align 4
  %151 = bitcast double** %arr_ptr249 to i8**
  store i8* %141, i8** %151, align 8
  store i1* %.sub529, i1** %mask_ptr250, align 8
  call void @print_float_arr(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @res_fs.CBD4AF54.0, i64 0, i64 0), i64 16, <{ i32, i32, double*, i1* }>* nonnull %out_arr_alloca246)
  ret void
}

define double @"__hugr__.$array.__unwrap_elem.7$$t(float64).664"({ i1, double } %0) local_unnamed_addr {
alloca_block:
  %.fca.0.extract = extractvalue { i1, double } %0, 0
  br i1 %.fca.0.extract, label %cond_667_case_1, label %cond_667_case_0

cond_667_case_1:                                  ; preds = %alloca_block
  %.fca.1.extract = extractvalue { i1, double } %0, 1
  ret double %.fca.1.extract

cond_667_case_0:                                  ; preds = %alloca_block
  tail call void @panic(i32 1001, i8* getelementptr inbounds ([52 x i8], [52 x i8]* @"e_Linear arr.27F92A51.0", i64 0, i64 0))
  unreachable
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind readnone willreturn
define { i1, double } @"__hugr__.$array.__comprehension.init.6$$t(float64).644"() local_unnamed_addr #0 {
alloca_block:
  ret { i1, double } { i1 false, double poison }
}

declare i8* @heap_alloc(i64) local_unnamed_addr

define i64 @"__hugr__.$array.__unwrap_elem.7$$t(int(6)).631"({ i1, i64 } %0) local_unnamed_addr {
alloca_block:
  %.fca.0.extract = extractvalue { i1, i64 } %0, 0
  br i1 %.fca.0.extract, label %cond_634_case_1, label %cond_634_case_0

cond_634_case_1:                                  ; preds = %alloca_block
  %.fca.1.extract = extractvalue { i1, i64 } %0, 1
  ret i64 %.fca.1.extract

cond_634_case_0:                                  ; preds = %alloca_block
  tail call void @panic(i32 1001, i8* getelementptr inbounds ([52 x i8], [52 x i8]* @"e_Linear arr.27F92A51.0", i64 0, i64 0))
  unreachable
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind readnone willreturn
define { i1, i64 } @"__hugr__.$array.__comprehension.init.6$$t(int(6)).611"() local_unnamed_addr #0 {
alloca_block:
  ret { i1, i64 } { i1 false, i64 poison }
}

define i1 @__hugr__.array.__read_bool.9.312({ i1, i64, i1 } %0) local_unnamed_addr {
alloca_block:
  %.fca.0.extract = extractvalue { i1, i64, i1 } %0, 0
  %.fca.1.extract = extractvalue { i1, i64, i1 } %0, 1
  br i1 %.fca.0.extract, label %cond_365_case_1, label %cond_365_case_0

cond_365_case_0:                                  ; preds = %alloca_block
  %.fca.2.extract = extractvalue { i1, i64, i1 } %0, 2
  br label %cond_exit_365

cond_365_case_1:                                  ; preds = %alloca_block
  %read_bool = tail call i1 @___read_future_bool(i64 %.fca.1.extract)
  tail call void @___dec_future_refcount(i64 %.fca.1.extract)
  br label %cond_exit_365

cond_exit_365:                                    ; preds = %cond_365_case_1, %cond_365_case_0
  %"03.0" = phi i1 [ %read_bool, %cond_365_case_1 ], [ %.fca.2.extract, %cond_365_case_0 ]
  ret i1 %"03.0"
}

define { i1, i64, i1 } @"__hugr__.$array.__unwrap_elem.7$$t(bool).598"({ i1, { i1, i64, i1 } } %0) local_unnamed_addr {
alloca_block:
  %.fca.0.extract11 = extractvalue { i1, { i1, i64, i1 } } %0, 0
  br i1 %.fca.0.extract11, label %cond_601_case_1, label %cond_601_case_0

cond_601_case_1:                                  ; preds = %alloca_block
  %1 = extractvalue { i1, { i1, i64, i1 } } %0, 1
  ret { i1, i64, i1 } %1

cond_601_case_0:                                  ; preds = %alloca_block
  tail call void @panic(i32 1001, i8* getelementptr inbounds ([52 x i8], [52 x i8]* @"e_Linear arr.27F92A51.0", i64 0, i64 0))
  unreachable
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind readnone willreturn
define { i1, i64 } @"__hugr__.$array.__comprehension.init.6$$t(qubit).414"() local_unnamed_addr #0 {
alloca_block:
  ret { i1, i64 } { i1 false, i64 poison }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind readnone willreturn
define { i1, { { i64, i64 }, i64 } } @__hugr__.__next__.170({ i64, i64 } %0) local_unnamed_addr #0 {
alloca_block:
  %.fca.0.extract84 = extractvalue { i64, i64 } %0, 0
  %.fca.1.extract85 = extractvalue { i64, i64 } %0, 1
  %1 = icmp slt i64 %.fca.0.extract84, %.fca.1.extract85
  %2 = add i64 %.fca.0.extract84, 1
  %"040.fca.0.insert" = insertvalue { i1, { { i64, i64 }, i64 } } poison, i1 %1, 0
  %"040.fca.1.0.0.insert" = insertvalue { i1, { { i64, i64 }, i64 } } %"040.fca.0.insert", i64 %2, 1, 0, 0
  %"040.fca.1.0.1.insert" = insertvalue { i1, { { i64, i64 }, i64 } } %"040.fca.1.0.0.insert", i64 %.fca.1.extract85, 1, 0, 1
  %"040.fca.1.1.insert" = insertvalue { i1, { { i64, i64 }, i64 } } %"040.fca.1.0.1.insert", i64 %.fca.0.extract84, 1, 1
  ret { i1, { { i64, i64 }, i64 } } %"040.fca.1.1.insert"
}

define i64 @__hugr__.__tk2_qalloc.391() local_unnamed_addr {
alloca_block:
  %qalloc = tail call i64 @___qalloc()
  %not_max.not = icmp eq i64 %qalloc, -1
  br i1 %not_max.not, label %id_bb, label %reset_bb

reset_bb:                                         ; preds = %alloca_block
  tail call void @___reset(i64 %qalloc)
  br label %id_bb

id_bb:                                            ; preds = %alloca_block, %reset_bb
  %0 = insertvalue { i1, i64 } { i1 true, i64 poison }, i64 %qalloc, 1
  %1 = select i1 %not_max.not, { i1, i64 } { i1 false, i64 poison }, { i1, i64 } %0
  %.fca.0.extract = extractvalue { i1, i64 } %1, 0
  br i1 %.fca.0.extract, label %cond_387_case_1, label %cond_387_case_0

cond_387_case_1:                                  ; preds = %id_bb
  %.fca.1.extract = extractvalue { i1, i64 } %1, 1
  ret i64 %.fca.1.extract

cond_387_case_0:                                  ; preds = %id_bb
  tail call void @panic(i32 1001, i8* getelementptr inbounds ([47 x i8], [47 x i8]* @"e_No more qu.3B2EEBF0.0", i64 0, i64 0))
  unreachable
}

define { { i1, i64 }*, i64 } @"__hugr__.$array.__setitem__.linear.4$$t(qubit)$n(10).418"({ { i1, i64 }*, i64 } returned %0, i64 %1, i64 %2) local_unnamed_addr {
alloca_block:
  %3 = icmp ult i64 %1, 10
  br i1 %3, label %cond_424_case_1, label %cond_424_case_0

cond_424_case_0:                                  ; preds = %alloca_block
  tail call void @panic(i32 1001, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @"e_Array inde.2A1CB845.0", i64 0, i64 0))
  unreachable

cond_424_case_1:                                  ; preds = %alloca_block
  %"421_05.fca.1.insert" = insertvalue { i1, i64 } { i1 true, i64 poison }, i64 %2, 1
  %.fca.1.extract56 = extractvalue { { i1, i64 }*, i64 } %0, 1
  %.fca.0.extract55 = extractvalue { { i1, i64 }*, i64 } %0, 0
  %4 = add i64 %.fca.1.extract56, %1
  %5 = getelementptr inbounds { i1, i64 }, { i1, i64 }* %.fca.0.extract55, i64 %4
  %6 = getelementptr inbounds { i1, i64 }, { i1, i64 }* %5, i64 0, i32 0
  %7 = load i1, i1* %6, align 1
  store { i1, i64 } %"421_05.fca.1.insert", { i1, i64 }* %5, align 4
  br i1 %7, label %cond_434_case_1, label %cond_exit_434

cond_434_case_1:                                  ; preds = %cond_424_case_1
  tail call void @panic(i32 1001, i8* getelementptr inbounds ([48 x i8], [48 x i8]* @"e_Linear arr.8A243695.0", i64 0, i64 0))
  unreachable

cond_exit_434:                                    ; preds = %cond_424_case_1
  ret { { i1, i64 }*, i64 } %0
}

define { i64, { { i1, i64 }*, i64 } } @"__hugr__.$array.__getitem__.linear.2$$t(qubit)$n(10).444"({ { i1, i64 }*, i64 } %0, i64 %1) local_unnamed_addr {
alloca_block:
  %2 = icmp ult i64 %1, 10
  br i1 %2, label %cond_450_case_1, label %cond_450_case_0

cond_450_case_0:                                  ; preds = %alloca_block
  tail call void @panic(i32 1001, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @"e_Array inde.2A1CB845.0", i64 0, i64 0))
  unreachable

cond_450_case_1:                                  ; preds = %alloca_block
  %.fca.1.extract60 = extractvalue { { i1, i64 }*, i64 } %0, 1
  %.fca.0.extract59 = extractvalue { { i1, i64 }*, i64 } %0, 0
  %3 = add i64 %.fca.1.extract60, %1
  %4 = getelementptr inbounds { i1, i64 }, { i1, i64 }* %.fca.0.extract59, i64 %3
  %5 = load { i1, i64 }, { i1, i64 }* %4, align 4
  %6 = bitcast { i1, i64 }* %4 to i8*
  call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 4 dereferenceable(16) %6, i8 0, i64 16, i1 false)
  %.fca.2.0.extract = extractvalue { i1, i64 } %5, 0
  br i1 %.fca.2.0.extract, label %cond_460_case_1, label %cond_460_case_0

cond_460_case_1:                                  ; preds = %cond_450_case_1
  %.fca.2.1.extract = extractvalue { i1, i64 } %5, 1
  %mrv = insertvalue { i64, { { i1, i64 }*, i64 } } undef, i64 %.fca.2.1.extract, 0
  %mrv40 = insertvalue { i64, { { i1, i64 }*, i64 } } %mrv, { { i1, i64 }*, i64 } %0, 1
  ret { i64, { { i1, i64 }*, i64 } } %mrv40

cond_460_case_0:                                  ; preds = %cond_450_case_1
  tail call void @panic(i32 1001, i8* getelementptr inbounds ([52 x i8], [52 x i8]* @"e_Linear arr.27F92A51.0", i64 0, i64 0))
  unreachable
}

define i64 @__hugr__.__tk2_x.378(i64 returned %0) local_unnamed_addr {
alloca_block:
  tail call void @___rxy(i64 %0, double 0x400921FB54442D18, double 0.000000e+00)
  ret i64 %0
}

define { { i1, { i1, i64, i1 } }*, i64 } @"__hugr__.$measure_array$$n(10).472"({ { i1, i64 }*, i64 } %0) local_unnamed_addr {
alloca_block:
  %1 = tail call i8* @heap_alloc(i64 320)
  call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 4 dereferenceable(320) %1, i8 0, i64 320, i1 false)
  %2 = insertvalue { { { i1, i64 }*, i64 }, i64 } poison, { { i1, i64 }*, i64 } %0, 0
  %3 = bitcast i8* %1 to { i1, { i1, i64, i1 } }*
  %"503_012.fca.1.insert141" = insertvalue { { { i1, i64 }*, i64 }, i64 } %2, i64 0, 1
  %4 = tail call { i1, { { { { i1, i64 }*, i64 }, i64 }, i64 } } @"__hugr__.$__next__$$t(qubit)$n(10).508"({ { { i1, i64 }*, i64 }, i64 } %"503_012.fca.1.insert141")
  %.fca.0.extract95142 = extractvalue { i1, { { { { i1, i64 }*, i64 }, i64 }, i64 } } %4, 0
  br i1 %.fca.0.extract95142, label %cond_560_case_1, label %loop_out

cond_560_case_1:                                  ; preds = %alloca_block, %loop_body
  %5 = phi { i1, { { { { i1, i64 }*, i64 }, i64 }, i64 } } [ %13, %loop_body ], [ %4, %alloca_block ]
  %"503_2.0143" = phi i64 [ %7, %loop_body ], [ 0, %alloca_block ]
  %6 = extractvalue { i1, { { { { i1, i64 }*, i64 }, i64 }, i64 } } %5, 1
  %.fca.1.extract92 = extractvalue { { { { i1, i64 }*, i64 }, i64 }, i64 } %6, 1
  %7 = add nuw nsw i64 %"503_2.0143", 1
  %8 = extractvalue { { { { i1, i64 }*, i64 }, i64 }, i64 } %6, 0
  %lazy_measure = tail call i64 @___lazy_measure(i64 %.fca.1.extract92)
  tail call void @___qfree(i64 %.fca.1.extract92)
  %exitcond.not = icmp eq i64 %"503_2.0143", 10
  br i1 %exitcond.not, label %cond_582_case_0.i, label %cond_582_case_1.i

cond_582_case_0.i:                                ; preds = %cond_560_case_1
  tail call void @panic(i32 1001, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @"e_Array inde.2A1CB845.0", i64 0, i64 0))
  unreachable

cond_582_case_1.i:                                ; preds = %cond_560_case_1
  %"574_054.fca.1.insert" = insertvalue { i1, i64, i1 } { i1 true, i64 poison, i1 poison }, i64 %lazy_measure, 1
  %9 = insertvalue { i1, { i1, i64, i1 } } { i1 true, { i1, i64, i1 } poison }, { i1, i64, i1 } %"574_054.fca.1.insert", 1
  %10 = getelementptr inbounds { i1, { i1, i64, i1 } }, { i1, { i1, i64, i1 } }* %3, i64 %"503_2.0143"
  %11 = load { i1, { i1, i64, i1 } }, { i1, { i1, i64, i1 } }* %10, align 4
  store { i1, { i1, i64, i1 } } %9, { i1, { i1, i64, i1 } }* %10, align 4
  %.fca.2.0.extract.i = extractvalue { i1, { i1, i64, i1 } } %11, 0
  %.fca.2.1.0.extract.i = extractvalue { i1, { i1, i64, i1 } } %11, 1, 0
  %12 = select i1 %.fca.2.0.extract.i, i1 %.fca.2.1.0.extract.i, i1 false
  br i1 %12, label %cond_404_case_1.i, label %loop_body

cond_404_case_1.i:                                ; preds = %cond_582_case_1.i
  %.fca.2.1.1.extract.i = extractvalue { i1, { i1, i64, i1 } } %11, 1, 1
  tail call void @___dec_future_refcount(i64 %.fca.2.1.1.extract.i)
  br label %loop_body

loop_body:                                        ; preds = %cond_404_case_1.i, %cond_582_case_1.i
  %13 = tail call { i1, { { { { i1, i64 }*, i64 }, i64 }, i64 } } @"__hugr__.$__next__$$t(qubit)$n(10).508"({ { { i1, i64 }*, i64 }, i64 } %8)
  %.fca.0.extract95 = extractvalue { i1, { { { { i1, i64 }*, i64 }, i64 }, i64 } } %13, 0
  br i1 %.fca.0.extract95, label %cond_560_case_1, label %loop_out

loop_out:                                         ; preds = %loop_body, %alloca_block
  %"124.fca.0.insert" = insertvalue { { i1, { i1, i64, i1 } }*, i64 } poison, { i1, { i1, i64, i1 } }* %3, 0
  %"124.fca.1.insert" = insertvalue { { i1, { i1, i64, i1 } }*, i64 } %"124.fca.0.insert", i64 0, 1
  ret { { i1, { i1, i64, i1 } }*, i64 } %"124.fca.1.insert"
}

declare void @heap_free(i8*) local_unnamed_addr

declare void @print_bool_arr(i8*, i64, <{ i32, i32, i1*, i1* }>*) local_unnamed_addr

define { { i1, i64 }*, i64 } @"__hugr__.$array.__setitem__.classical.3$$t(int(6))$n(100).615"({ { i1, i64 }*, i64 } returned %0, i64 %1, i64 %2) local_unnamed_addr {
alloca_block:
  %3 = icmp ult i64 %1, 100
  br i1 %3, label %cond_621_case_1, label %cond_621_case_0

cond_621_case_1:                                  ; preds = %alloca_block
  %"619_05.fca.1.insert" = insertvalue { i1, i64 } { i1 true, i64 poison }, i64 %2, 1
  %.fca.1.extract49 = extractvalue { { i1, i64 }*, i64 } %0, 1
  %.fca.0.extract48 = extractvalue { { i1, i64 }*, i64 } %0, 0
  %4 = add i64 %.fca.1.extract49, %1
  %5 = getelementptr inbounds { i1, i64 }, { i1, i64 }* %.fca.0.extract48, i64 %4
  store { i1, i64 } %"619_05.fca.1.insert", { i1, i64 }* %5, align 4
  ret { { i1, i64 }*, i64 } %0

cond_621_case_0:                                  ; preds = %alloca_block
  tail call void @panic(i32 1001, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @"e_Array inde.2A1CB845.0", i64 0, i64 0))
  unreachable
}

declare void @print_int_arr(i8*, i64, <{ i32, i32, i64*, i1* }>*) local_unnamed_addr

define { { i1, double }*, i64 } @"__hugr__.$array.__setitem__.classical.3$$t(float64)$n(100).648"({ { i1, double }*, i64 } returned %0, i64 %1, double %2) local_unnamed_addr {
alloca_block:
  %3 = icmp ult i64 %1, 100
  br i1 %3, label %cond_654_case_1, label %cond_654_case_0

cond_654_case_1:                                  ; preds = %alloca_block
  %"652_05.fca.1.insert" = insertvalue { i1, double } { i1 true, double poison }, double %2, 1
  %.fca.1.extract49 = extractvalue { { i1, double }*, i64 } %0, 1
  %.fca.0.extract48 = extractvalue { { i1, double }*, i64 } %0, 0
  %4 = add i64 %.fca.1.extract49, %1
  %5 = getelementptr inbounds { i1, double }, { i1, double }* %.fca.0.extract48, i64 %4
  store { i1, double } %"652_05.fca.1.insert", { i1, double }* %5, align 8
  ret { { i1, double }*, i64 } %0

cond_654_case_0:                                  ; preds = %alloca_block
  tail call void @panic(i32 1001, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @"e_Array inde.2A1CB845.0", i64 0, i64 0))
  unreachable
}

declare void @print_float_arr(i8*, i64, <{ i32, i32, double*, i1* }>*) local_unnamed_addr

; Function Attrs: mustprogress nofree norecurse nosync nounwind readnone willreturn
define { i1, { i1, i64, i1 } } @"__hugr__.$array.__comprehension.init.6$$t(bool).480"() local_unnamed_addr #0 {
alloca_block:
  ret { i1, { i1, i64, i1 } } { i1 false, { i1, i64, i1 } poison }
}

declare i1 @___read_future_bool(i64) local_unnamed_addr

declare void @___dec_future_refcount(i64) local_unnamed_addr

; Function Attrs: noreturn
declare void @panic(i32, i8*) local_unnamed_addr #1

; Function Attrs: mustprogress nofree norecurse nosync nounwind readnone willreturn
define { { { i1, i64 }*, i64 }, i64 } @"__hugr__.$__iter__$$t(qubit)$n(10).488"({ { i1, i64 }*, i64 } %0) local_unnamed_addr #0 {
alloca_block:
  %1 = insertvalue { { { i1, i64 }*, i64 }, i64 } poison, { { i1, i64 }*, i64 } %0, 0
  %"012.fca.1.insert" = insertvalue { { { i1, i64 }*, i64 }, i64 } %1, i64 0, 1
  ret { { { i1, i64 }*, i64 }, i64 } %"012.fca.1.insert"
}

define { i1, { { { { i1, i64 }*, i64 }, i64 }, i64 } } @"__hugr__.$__next__$$t(qubit)$n(10).508"({ { { i1, i64 }*, i64 }, i64 } %0) local_unnamed_addr {
alloca_block:
  %.fca.1.extract96 = extractvalue { { { i1, i64 }*, i64 }, i64 } %0, 1
  %1 = extractvalue { { { i1, i64 }*, i64 }, i64 } %0, 0
  %.fca.0.extract80 = extractvalue { { i1, i64 }*, i64 } %1, 0
  %.fca.1.extract81 = extractvalue { { i1, i64 }*, i64 } %1, 1
  %2 = icmp slt i64 %.fca.1.extract96, 10
  br i1 %2, label %7, label %"__hugr__.$ArrayIter._assert_all_used.helper.5$$t(qubit).538.exit"

3:                                                ; preds = %41, %"__hugr__.$array.__getitem__.linear.2$$t(qubit)$n(10).444.exit"
  %"02.sroa.9.0" = phi i64 [ %8, %"__hugr__.$array.__getitem__.linear.2$$t(qubit)$n(10).444.exit" ], [ poison, %41 ]
  %"02.sroa.12.0" = phi i64 [ %.fca.2.1.extract.i, %"__hugr__.$array.__getitem__.linear.2$$t(qubit)$n(10).444.exit" ], [ poison, %41 ]
  %"029.fca.0.insert" = insertvalue { i1, { { { { i1, i64 }*, i64 }, i64 }, i64 } } poison, i1 %2, 0
  %"029.fca.1.0.0.0.insert" = insertvalue { i1, { { { { i1, i64 }*, i64 }, i64 }, i64 } } %"029.fca.0.insert", { i1, i64 }* %.fca.0.extract80, 1, 0, 0, 0
  %"029.fca.1.0.0.1.insert" = insertvalue { i1, { { { { i1, i64 }*, i64 }, i64 }, i64 } } %"029.fca.1.0.0.0.insert", i64 %.fca.1.extract81, 1, 0, 0, 1
  %"029.fca.1.0.1.insert" = insertvalue { i1, { { { { i1, i64 }*, i64 }, i64 }, i64 } } %"029.fca.1.0.0.1.insert", i64 %"02.sroa.9.0", 1, 0, 1
  %"029.fca.1.1.insert" = insertvalue { i1, { { { { i1, i64 }*, i64 }, i64 }, i64 } } %"029.fca.1.0.1.insert", i64 %"02.sroa.12.0", 1, 1
  ret { i1, { { { { i1, i64 }*, i64 }, i64 }, i64 } } %"029.fca.1.1.insert"

"__hugr__.$ArrayIter._assert_all_used.helper.5$$t(qubit).538.exit": ; preds = %alloca_block
  %4 = tail call i8* @heap_alloc(i64 0)
  %5 = getelementptr inbounds { i1, i64 }, { i1, i64 }* %.fca.0.extract80, i64 %.fca.1.extract81, i32 0
  %6 = load i1, i1* %5, align 1
  br i1 %6, label %cond_541_case_1.i, label %"__hugr__.$ArrayIter._assert_all_used.helper.5$$t(qubit).538.exit.1"

7:                                                ; preds = %alloca_block
  %8 = add nsw i64 %.fca.1.extract96, 1
  %9 = icmp ult i64 %.fca.1.extract96, 10
  br i1 %9, label %cond_450_case_1.i, label %cond_450_case_0.i

cond_450_case_0.i:                                ; preds = %7
  tail call void @panic(i32 1001, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @"e_Array inde.2A1CB845.0", i64 0, i64 0))
  unreachable

cond_450_case_1.i:                                ; preds = %7
  %10 = add i64 %.fca.1.extract81, %.fca.1.extract96
  %11 = getelementptr inbounds { i1, i64 }, { i1, i64 }* %.fca.0.extract80, i64 %10
  %12 = load { i1, i64 }, { i1, i64 }* %11, align 4
  %13 = bitcast { i1, i64 }* %11 to i8*
  tail call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 4 dereferenceable(16) %13, i8 0, i64 16, i1 false)
  %.fca.2.0.extract.i = extractvalue { i1, i64 } %12, 0
  br i1 %.fca.2.0.extract.i, label %"__hugr__.$array.__getitem__.linear.2$$t(qubit)$n(10).444.exit", label %cond_460_case_0.i

cond_460_case_0.i:                                ; preds = %cond_450_case_1.i
  tail call void @panic(i32 1001, i8* getelementptr inbounds ([52 x i8], [52 x i8]* @"e_Linear arr.27F92A51.0", i64 0, i64 0))
  unreachable

"__hugr__.$array.__getitem__.linear.2$$t(qubit)$n(10).444.exit": ; preds = %cond_450_case_1.i
  %.fca.2.1.extract.i = extractvalue { i1, i64 } %12, 1
  br label %3

"__hugr__.$ArrayIter._assert_all_used.helper.5$$t(qubit).538.exit.1": ; preds = %"__hugr__.$ArrayIter._assert_all_used.helper.5$$t(qubit).538.exit"
  %14 = add i64 %.fca.1.extract81, 1
  %15 = getelementptr inbounds { i1, i64 }, { i1, i64 }* %.fca.0.extract80, i64 %14, i32 0
  %16 = load i1, i1* %15, align 1
  br i1 %16, label %cond_541_case_1.i, label %"__hugr__.$ArrayIter._assert_all_used.helper.5$$t(qubit).538.exit.2"

"__hugr__.$ArrayIter._assert_all_used.helper.5$$t(qubit).538.exit.2": ; preds = %"__hugr__.$ArrayIter._assert_all_used.helper.5$$t(qubit).538.exit.1"
  %17 = add i64 %.fca.1.extract81, 2
  %18 = getelementptr inbounds { i1, i64 }, { i1, i64 }* %.fca.0.extract80, i64 %17, i32 0
  %19 = load i1, i1* %18, align 1
  br i1 %19, label %cond_541_case_1.i, label %"__hugr__.$ArrayIter._assert_all_used.helper.5$$t(qubit).538.exit.3"

"__hugr__.$ArrayIter._assert_all_used.helper.5$$t(qubit).538.exit.3": ; preds = %"__hugr__.$ArrayIter._assert_all_used.helper.5$$t(qubit).538.exit.2"
  %20 = add i64 %.fca.1.extract81, 3
  %21 = getelementptr inbounds { i1, i64 }, { i1, i64 }* %.fca.0.extract80, i64 %20, i32 0
  %22 = load i1, i1* %21, align 1
  br i1 %22, label %cond_541_case_1.i, label %"__hugr__.$ArrayIter._assert_all_used.helper.5$$t(qubit).538.exit.4"

"__hugr__.$ArrayIter._assert_all_used.helper.5$$t(qubit).538.exit.4": ; preds = %"__hugr__.$ArrayIter._assert_all_used.helper.5$$t(qubit).538.exit.3"
  %23 = add i64 %.fca.1.extract81, 4
  %24 = getelementptr inbounds { i1, i64 }, { i1, i64 }* %.fca.0.extract80, i64 %23, i32 0
  %25 = load i1, i1* %24, align 1
  br i1 %25, label %cond_541_case_1.i, label %"__hugr__.$ArrayIter._assert_all_used.helper.5$$t(qubit).538.exit.5"

"__hugr__.$ArrayIter._assert_all_used.helper.5$$t(qubit).538.exit.5": ; preds = %"__hugr__.$ArrayIter._assert_all_used.helper.5$$t(qubit).538.exit.4"
  %26 = add i64 %.fca.1.extract81, 5
  %27 = getelementptr inbounds { i1, i64 }, { i1, i64 }* %.fca.0.extract80, i64 %26, i32 0
  %28 = load i1, i1* %27, align 1
  br i1 %28, label %cond_541_case_1.i, label %"__hugr__.$ArrayIter._assert_all_used.helper.5$$t(qubit).538.exit.6"

"__hugr__.$ArrayIter._assert_all_used.helper.5$$t(qubit).538.exit.6": ; preds = %"__hugr__.$ArrayIter._assert_all_used.helper.5$$t(qubit).538.exit.5"
  %29 = add i64 %.fca.1.extract81, 6
  %30 = getelementptr inbounds { i1, i64 }, { i1, i64 }* %.fca.0.extract80, i64 %29, i32 0
  %31 = load i1, i1* %30, align 1
  br i1 %31, label %cond_541_case_1.i, label %"__hugr__.$ArrayIter._assert_all_used.helper.5$$t(qubit).538.exit.7"

"__hugr__.$ArrayIter._assert_all_used.helper.5$$t(qubit).538.exit.7": ; preds = %"__hugr__.$ArrayIter._assert_all_used.helper.5$$t(qubit).538.exit.6"
  %32 = add i64 %.fca.1.extract81, 7
  %33 = getelementptr inbounds { i1, i64 }, { i1, i64 }* %.fca.0.extract80, i64 %32, i32 0
  %34 = load i1, i1* %33, align 1
  br i1 %34, label %cond_541_case_1.i, label %"__hugr__.$ArrayIter._assert_all_used.helper.5$$t(qubit).538.exit.8"

"__hugr__.$ArrayIter._assert_all_used.helper.5$$t(qubit).538.exit.8": ; preds = %"__hugr__.$ArrayIter._assert_all_used.helper.5$$t(qubit).538.exit.7"
  %35 = add i64 %.fca.1.extract81, 8
  %36 = getelementptr inbounds { i1, i64 }, { i1, i64 }* %.fca.0.extract80, i64 %35, i32 0
  %37 = load i1, i1* %36, align 1
  br i1 %37, label %cond_541_case_1.i, label %"__hugr__.$ArrayIter._assert_all_used.helper.5$$t(qubit).538.exit.9"

"__hugr__.$ArrayIter._assert_all_used.helper.5$$t(qubit).538.exit.9": ; preds = %"__hugr__.$ArrayIter._assert_all_used.helper.5$$t(qubit).538.exit.8"
  %38 = add i64 %.fca.1.extract81, 9
  %39 = getelementptr inbounds { i1, i64 }, { i1, i64 }* %.fca.0.extract80, i64 %38, i32 0
  %40 = load i1, i1* %39, align 1
  br i1 %40, label %cond_541_case_1.i, label %41

41:                                               ; preds = %"__hugr__.$ArrayIter._assert_all_used.helper.5$$t(qubit).538.exit.9"
  %42 = bitcast { i1, i64 }* %.fca.0.extract80 to i8*
  tail call void @heap_free(i8* %42)
  tail call void @heap_free(i8* %4)
  br label %3

cond_541_case_1.i:                                ; preds = %"__hugr__.$ArrayIter._assert_all_used.helper.5$$t(qubit).538.exit.9", %"__hugr__.$ArrayIter._assert_all_used.helper.5$$t(qubit).538.exit.8", %"__hugr__.$ArrayIter._assert_all_used.helper.5$$t(qubit).538.exit.7", %"__hugr__.$ArrayIter._assert_all_used.helper.5$$t(qubit).538.exit.6", %"__hugr__.$ArrayIter._assert_all_used.helper.5$$t(qubit).538.exit.5", %"__hugr__.$ArrayIter._assert_all_used.helper.5$$t(qubit).538.exit.4", %"__hugr__.$ArrayIter._assert_all_used.helper.5$$t(qubit).538.exit.3", %"__hugr__.$ArrayIter._assert_all_used.helper.5$$t(qubit).538.exit.2", %"__hugr__.$ArrayIter._assert_all_used.helper.5$$t(qubit).538.exit.1", %"__hugr__.$ArrayIter._assert_all_used.helper.5$$t(qubit).538.exit"
  tail call void @panic(i32 1001, i8* getelementptr inbounds ([69 x i8], [69 x i8]* @e_ArrayIter..ED8B8605.0, i64 0, i64 0))
  unreachable
}

declare i64 @___lazy_measure(i64) local_unnamed_addr

declare void @___qfree(i64) local_unnamed_addr

define { { i1, { i1, i64, i1 } }*, i64 } @"__hugr__.$array.__setitem__.classical.3$$t(bool)$n(10).576"({ { i1, { i1, i64, i1 } }*, i64 } returned %0, i64 %1, { i1, i64, i1 } %2) local_unnamed_addr {
alloca_block:
  %3 = icmp ult i64 %1, 10
  br i1 %3, label %cond_582_case_1, label %cond_582_case_0

cond_582_case_0:                                  ; preds = %alloca_block
  tail call void @panic(i32 1001, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @"e_Array inde.2A1CB845.0", i64 0, i64 0))
  unreachable

cond_582_case_1:                                  ; preds = %alloca_block
  %4 = insertvalue { i1, { i1, i64, i1 } } { i1 true, { i1, i64, i1 } poison }, { i1, i64, i1 } %2, 1
  %.fca.1.extract74 = extractvalue { { i1, { i1, i64, i1 } }*, i64 } %0, 1
  %.fca.0.extract73 = extractvalue { { i1, { i1, i64, i1 } }*, i64 } %0, 0
  %5 = add i64 %.fca.1.extract74, %1
  %6 = getelementptr inbounds { i1, { i1, i64, i1 } }, { i1, { i1, i64, i1 } }* %.fca.0.extract73, i64 %5
  %7 = load { i1, { i1, i64, i1 } }, { i1, { i1, i64, i1 } }* %6, align 4
  store { i1, { i1, i64, i1 } } %4, { i1, { i1, i64, i1 } }* %6, align 4
  %.fca.2.0.extract = extractvalue { i1, { i1, i64, i1 } } %7, 0
  %.fca.2.1.0.extract = extractvalue { i1, { i1, i64, i1 } } %7, 1, 0
  %8 = select i1 %.fca.2.0.extract, i1 %.fca.2.1.0.extract, i1 false
  br i1 %8, label %cond_404_case_1, label %cond_exit_368

cond_404_case_1:                                  ; preds = %cond_582_case_1
  %.fca.2.1.1.extract = extractvalue { i1, { i1, i64, i1 } } %7, 1, 1
  tail call void @___dec_future_refcount(i64 %.fca.2.1.1.extract)
  br label %cond_exit_368

cond_exit_368:                                    ; preds = %cond_582_case_1, %cond_404_case_1
  ret { { i1, { i1, i64, i1 } }*, i64 } %0
}

define {} @"__hugr__.$ArrayIter._assert_all_used.helper.5$$t(qubit).538"({ i1, i64 } %0) local_unnamed_addr {
alloca_block:
  %.fca.0.extract = extractvalue { i1, i64 } %0, 0
  br i1 %.fca.0.extract, label %cond_541_case_1, label %cond_exit_541

cond_541_case_1:                                  ; preds = %alloca_block
  tail call void @panic(i32 1001, i8* getelementptr inbounds ([69 x i8], [69 x i8]* @e_ArrayIter..ED8B8605.0, i64 0, i64 0))
  unreachable

cond_exit_541:                                    ; preds = %alloca_block
  ret {} undef
}

declare i64 @___qalloc() local_unnamed_addr

declare void @___reset(i64) local_unnamed_addr

declare void @___rxy(i64, double, double) local_unnamed_addr

define i64 @qmain(i64 %0) local_unnamed_addr {
entry:
  tail call void @setup(i64 %0)
  tail call void @__hugr__.main.1()
  %1 = tail call i64 @teardown()
  ret i64 %1
}

declare void @setup(i64) local_unnamed_addr

declare i64 @teardown() local_unnamed_addr

; Function Attrs: argmemonly nofree nounwind willreturn writeonly
declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #2

attributes #0 = { mustprogress nofree norecurse nosync nounwind readnone willreturn }
attributes #1 = { noreturn }
attributes #2 = { argmemonly nofree nounwind willreturn writeonly }

!name = !{!0}

!0 = !{!"mainlib"}
